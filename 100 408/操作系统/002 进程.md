每一个运行的程序：进程，拥有自己的`Processing ID` 进程ID / PID。

一个进程的实体组成（均在RAM中）：
- PCB（供操作系统使用）（进程存在唯一标识）
- 程序段
- 数据段
# PCB 进程控制块
进程存在的唯一标志，进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。

操作系统对进程进行管理工作所需的信息都存在PCB中。
# 进程状态及转变(PCB中的变量state表示状态)
当进程被CPU处理时为运行态，在内存中等待CPU的为就绪态。

当被CPU处理时要等待其他某个资源时，会被操作系统变为阻塞态（等资源可用时切换为就绪态）。

进程可以执行exit系统调用变为终止态，回收相关资源（内存、PCB等）。
```text
创建态 -> 就绪态 <-> 运行态 -> 终止态
	    	↑		  ↓
			   阻塞态
```
# 进程控制
通过原语（原子性）进行进程控制。

可以用关中断指令（CPU不再检查中断信号）和开中断指令两个特权指令实现原子性。

由于CPU的 PSW PC IR 通用寄存器等是唯一的，在切换进程时会更新里面的数据，于是便会将一些关键信息存入相应进程的PCB存储起来，等待再次恢复数据。
# 进程通信
两个进程产生数据交互。各个进程拥有的内存地址空间相互独立。
- 共享存储：申请一片共享存储区映射到进程的虚拟地址恐空间（内存地址空间 = 自身 + 共享存储区）（加一个段表项即可）。
- 消息传递：以格式化的消息为单位。通过操作系统提供的“发送消息/接收消息”两条原语进行数据交换。消息分为消息头和消息体。消息头中包括发送PID，目标PID等格式化消息。
	- 直接通信方式，直接发送目标PID进程。
	- 简介通信方式，通过“信箱”间接通信。
- 管道通信：数据流动是单向的（半双工通信，如果想要双向则要设置两条管道）。“管道”是一个特殊的共享文件，又名`pipe`文件。各进程要互斥地访问管道。管道写满时，写进程将阻塞，直到读进程将管道中数据读走才会唤醒。管道中数据读出就彻底消失。
# 信号
信号量`Semaphore`实现进程间同步、互斥。

信号`signal`实现进程间通信。通知某个进程某个特定事件已经发生。

进程发送指令（如`kill(target_pid,signal_id)`）目标进程的PCB由`pending`待处理信号进行处理。`blocking`设置阻塞信号。
```text
信号类型
	    1 2 3 4 5 6 7 8
pending 1 0 0 0 0 0 0 1
block.g 0 0 0 0 0 0 1 1
```
当进程从内核态转为用户态时检查是否有待处理信号：

`pending & ~blocking` &：按位与 ~：按位取反。 -> `10000000`（第八位为阻塞信号不处理）。处理信号后重置`pending`为0。
# 线程
引入线程->线程成为程序执行流的最小单位。每个进程可以有多个线程，每个线程都是不同的代码。各线程可以并发。每个线程也都会有ID，TCB，就绪阻塞运行三种状态。
# 线程实现方式
内核级线程：操作系统层面实现的线程。内核线程与用户线程一对一。
多线程：
- 多对一模型：多个用户线程对一个内核线程多对一。
- 多对多模型。
# 线程状态及转换
```text
就绪态 <-> 运行态
  ↑		    ↓
	 阻塞态
```
同样会有TCB、线程表。
# 调度算法
- 先来先服务：非抢占式。“公平角度”。对长作业有利，短作业不利。
- 短作业优先：默认非抢占式。会产生长作业饥饿。
- 高相应比优先：非抢占式。`相应比=（等待时间+要求服务时间）/要求服务时间`。
- 时间片轮转调度算法：抢占式。公平轮流执行时间片。时间片一到就转换。
- 优先级调度算法：每个作业/进程有自己的优先级。
- 多级反馈队列调度算法：抢占式。
# 锁
```text
进入区
临界区
退出区
剩余区
```
- 互斥锁`mutex lock`：特点是忙等待，当一个进程在临界区，其他进程需要循环调用获取锁。循环忙等的互斥锁可称为自旋锁`spin lock`。
# 信号量
用户进程可以通过信号量以及原语实现进程互斥、进程同步。
- 信号量其实就是一个变量，表示系统中某个资源的数量（如果小于0表示有进程在等待资源）。
	- **整型信号量（计数型信号量）**：可用于多个资源的访问控制，只支持 `P`（wait） 和 `V`（signal） 两种原子操作。
	- **记录型信号量（或称同步信号量）**：在资源不可用时，进程会自动进入**阻塞队列**等待，而不会进行忙等（busy waiting），直到被其他进程通过 `signal` 唤醒。
- 原语：
	- `wait(S)`：若 S > 0，则 S 减 1；否则阻塞当前进程。
	- `signal(S)`：将 S 加 1，若有进程阻塞在该信号量上，则唤醒其中一个。
# 死锁
两个或多个进程循环等待对方手里的资源。发生死锁的进程一定是阻塞态。
- 互斥条件
- 不可剥夺条件
- 请求和保持条件
- 循环等待条件
死锁处理策略：
- 预防死锁
- 避免死锁：银行家算法。
- 检测和解除死锁
