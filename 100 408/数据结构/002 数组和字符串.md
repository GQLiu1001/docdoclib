# leetcode724 寻找数组的中心下标 （前缀和）
把从头开始的累加结果先存起来，就可以**O(1)** 算出任意子区间的总和。

找到中间的`i`将整个`sum`(先得到) 分成三部分 `leftSum` `nums[i]` `rightSum` 最终如果有输出 那么 `leftSum == rightSum` 也就是有返回的条件就是 `if(2*leftSum+nums[i] == total){...}`   。

数学公式： `leftSum + rightSum + nums[i] = total` 在题目要求下 `leftSum = rightSum`。

前缀和特点：
- 子数组和 / 区间和 问题。
# leetcode35 搜索插入位置 (双边双指针+二分)
双指针+二分保证时间复杂度为`O(log n)` 。

二分法思想：不是移动`mid`而是移动`left` 或者 `right`。

数学公式：`mid = left +(right - left)`然后 **根据大小获取结果或者更新**  `left` 或者 `right`。

二分法特点：
- **单调递增 / 递减**或**满足某种性质的有序空间**。
- 双指针在两边形成**边界控制**。
- 终止条件 `while (left <= right)`。
# leetcode56 合并区间 (排序 + 前后双指针)
注意题目给的二维数组没有排序，要用

`Arrays.sort(intervals, (a, b) - Integer.compare(a[0], b[0]));`

根据起点排序。

二分法思想：移动 `i` 与 `i+1`。

数学公式：区间合并关键点前一个的最大也就是`[i][1]` 要大于`[i+1][0]`触发合并。注意要用`Math.max(current[1], next[1])`获取最大的有边界。

二维/一维数组特点：
- 因为不能确定多长，用`List<int>`或`List<int[]>`来存储所需元素。用`.add()`添加元素。用`.toArray()`返回结果。特殊点：
`return merged.toArray(new int[merged.size()][]);`因为已经存储了第二个也就是`int[]`只需要获取第一维数组长度。

